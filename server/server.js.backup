const express = require('express');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const JSZip = require('jszip');
const cors = require('cors');

const app = express();
const PORT = 4000;

// Middleware
app.use(cors());
app.use(express.json());

// Configuration multer pour upload
const upload = multer({ dest: 'uploads/' });

// Dossiers
const uploadsDir = path.join(__dirname, 'uploads');
const downloadsDir = path.join(__dirname, 'downloads');

// Cr√©er les dossiers s'ils n'existent pas
if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir);
if (!fs.existsSync(downloadsDir)) fs.mkdirSync(downloadsDir);

// Fonction utilitaire pour s√©curiser les noms de fichiers
function safeFilename(filename) {
  return filename.replace(/[^a-zA-Z0-9._-]/g, '_');
}

// ===== FONCTION CORRIG√âE : REMPLACEMENT PAR SHAPE SP√âCIFIQUE =====
async function remplacerPlaceholdersParShape(content, references) {
  console.log('üîÑ [REMPLACEMENT] D√©but du remplacement par shape nomm√©e');
  console.log(`üìä [REMPLACEMENT] ${references.length} r√©f√©rences √† traiter`);
  
  const files = Object.keys(content.files);
  let replacements = 0;
  
  for (const fileName of files) {
    if (fileName.includes('slide') && fileName.endsWith('.xml')) {
      const file = content.files[fileName];
      if (!file.dir) {
        let xmlContent = await file.async('string');
        let fileModified = false;
        
        console.log(`üìÑ [REMPLACEMENT] Traitement de ${fileName}`);
        
        // Pour chaque r√©f√©rence, traiter la shape correspondante
        for (let refIndex = 0; refIndex < Math.min(references.length, 5); refIndex++) {
          const shapeName = `reference_${refIndex + 1}`;
          const ref = references[refIndex];
          
          console.log(`   üéØ [REMPLACEMENT] Traitement de ${shapeName} avec r√©f√©rence ${refIndex + 1}`);
          console.log(`   üìã [REMPLACEMENT] Donn√©es: ${ref.nom_projet || ref.residence} - ${ref.client || ref.moa}`);
          
          // Pattern plus pr√©cis pour isoler une shape sp√©cifique
          const shapePattern = new RegExp(
            `(<p:sp[\\s\\S]*?<p:cNvPr[^>]*name="${shapeName}"[\\s\\S]*?<\\/p:sp>)`,
            'g'
          );
          
          let shapeMatch = shapePattern.exec(xmlContent);
          if (shapeMatch) {
            console.log(`     ‚úÖ [REMPLACEMENT] Shape ${shapeName} trouv√©e`);
            
            let shapeContent = shapeMatch[1];
            let originalShapeContent = shapeContent;
            
            // Remplacer tous les placeholders dans cette shape sp√©cifique
            const residence = ref.nom_projet || ref.residence || `Projet ${refIndex + 1}`;
            const moa = ref.client || ref.moa || 'Client non sp√©cifi√©';
            const montant = ref.montant ? `${ref.montant.toLocaleString()} ‚Ç¨` : 'Non sp√©cifi√©';
            const travaux = ref.type_mission || ref.travaux || 'Mission non sp√©cifi√©e';
            const realisation = ref.annee || ref.realisation || 'Ann√©e non sp√©cifi√©e';
            
            // Log pour d√©bogage
            console.log(`       üîç Avant remplacement dans shape ${shapeName}:`, shapeContent.includes('{{REF_TRAVAUX}}') ? 'CONTIENT {{REF_TRAVAUX}}' : 'NE CONTIENT PAS {{REF_TRAVAUX}}');
            
            shapeContent = shapeContent.replace(/\{\{REF_RESIDENCE\}\}/g, residence);
            shapeContent = shapeContent.replace(/\{\{REF_MOA\}\}/g, moa);
            shapeContent = shapeContent.replace(/\{\{REF_MONTANT\}\}/g, montant);
            shapeContent = shapeContent.replace(/\{\{REF_TRAVAUX\}\}/g, travaux);
            shapeContent = shapeContent.replace(/\{\{REF_REALISATION\}\}/g, realisation);
            
            // V√©rification apr√®s remplacement
            console.log(`       ‚úÖ Apr√®s remplacement dans shape ${shapeName}:`, shapeContent.includes('{{REF_TRAVAUX}}') ? 'CONTIENT ENCORE {{REF_TRAVAUX}}' : 'NE CONTIENT PLUS {{REF_TRAVAUX}}');
            
            console.log(`       ‚Üí REF_RESIDENCE = "${residence}"`);
            console.log(`       ‚Üí REF_MOA = "${moa}"`);
            console.log(`       ‚Üí REF_MONTANT = "${montant}"`);
            console.log(`       ‚Üí REF_TRAVAUX = "${travaux}"`);
            console.log(`       ‚Üí REF_REALISATION = "${realisation}"`);
            
            // Remplacer la shape originale par la shape modifi√©e
            xmlContent = xmlContent.replace(originalShapeContent, shapeContent);
            
            fileModified = true;
            replacements++;
            console.log(`     ‚úÖ [REMPLACEMENT] Shape ${shapeName} mise √† jour`);
          } else {
            console.log(`     ‚ö†Ô∏è [REMPLACEMENT] Shape ${shapeName} non trouv√©e dans ${fileName}`);
          }
        }
        
        if (fileModified) {
          content.file(fileName, xmlContent);
          console.log(`   ‚úÖ Fichier ${fileName} modifi√©`);
        }
      }
    }
  }
  
  console.log(`‚úÖ [REMPLACEMENT] ${replacements} shapes mises √† jour au total`);
  return replacements;
}

// ===== FONCTION ALTERNATIVE : MASQUAGE PAR SUPPRESSION DE CONTENU =====
async function masquerShapesParSuppressionContenu(content, references) {
  console.log('üé≠ [MASQUAGE-SIMPLE] Suppression du contenu des shapes vides');
  
  const files = Object.keys(content.files);
  let shapesVidees = 0;
  
  for (const fileName of files) {
    if (fileName.includes('slide') && fileName.endsWith('.xml')) {
      const file = content.files[fileName];
      if (!file.dir) {
        let xmlContent = await file.async('string');
        let fileModified = false;
        
        // Pour chaque shape de r√©f√©rence vide
        for (let i = references.length + 1; i <= 5; i++) {
          // Pattern pour trouver tout le contenu texte d'une shape sp√©cifique
          const textContentPattern = new RegExp(
            `(<p:sp[\\s\\S]*?<p:cNvPr[^>]*name="reference_${i}"[\\s\\S]*?<p:txBody>)([\\s\\S]*?)(<\\/p:txBody>[\\s\\S]*?<\\/p:sp>)`,
            'g'
          );
          
          if (textContentPattern.test(xmlContent)) {
            console.log(`   üóëÔ∏è [MASQUAGE-SIMPLE] Vidage de reference_${i}`);
            
            // Remplacer tout le contenu texte par un contenu vide
            xmlContent = xmlContent.replace(textContentPattern, (match, before, textContent, after) => {
              return `${before}<a:bodyPr/><a:lstStyle/><a:p><a:endParaRPr/></a:p>${after}`;
            });
            
            fileModified = true;
            shapesVidees++;
          } else {
            console.log(`   ‚ÑπÔ∏è [MASQUAGE-SIMPLE] reference_${i} non trouv√©e`);
          }
        }
        
        if (fileModified) {
          content.file(fileName, xmlContent);
        }
      }
    }
  }
  
  console.log(`‚úÖ [MASQUAGE-SIMPLE] ${shapesVidees} shapes vid√©es`);
  return shapesVidees;
}

// ===== FONCTION DE DEBUG APPROFONDI =====
async function debugCompletStructure(content) {
  console.log('\nüîç [DEBUG] === ANALYSE COMPL√àTE DE LA STRUCTURE ===');
  
  const files = Object.keys(content.files);
  
  for (const fileName of files) {
    if (fileName.includes('slide') && fileName.endsWith('.xml')) {
      const file = content.files[fileName];
      if (!file.dir) {
        const xmlContent = await file.async('string');
        
        console.log(`\nüìÑ [DEBUG] ======= FICHIER: ${fileName} =======`);
        
        // 1. Chercher TOUS les noms de shapes
        console.log('\nüéØ [DEBUG] TOUTES LES SHAPES TROUV√âES :');
        const shapeNamePattern = /<p:cNvPr[^>]*name="([^"]*)"[^>]*>/g;
        let match;
        let shapeIndex = 1;
        
        while ((match = shapeNamePattern.exec(xmlContent)) !== null) {
          console.log(`   ${shapeIndex}. "${match[1]}"`);
          shapeIndex++;
        }
        
        // 2. Chercher sp√©cifiquement les shapes "reference_"
        console.log('\nüîç [DEBUG] SHAPES "reference_" TROUV√âES :');
        const referenceShapePattern = /<p:cNvPr[^>]*name="(reference_[^"]*)"[^>]*>/g;
        let refMatch;
        let refFound = false;
        
        while ((refMatch = referenceShapePattern.exec(xmlContent)) !== null) {
          console.log(`   ‚úÖ Trouv√©: "${refMatch[1]}"`);
          refFound = true;
        }
        
        if (!refFound) {
          console.log('   ‚ùå AUCUNE shape "reference_" trouv√©e !');
        }
        
        // 3. Chercher TOUS les placeholders
        console.log('\nüìã [DEBUG] TOUS LES PLACEHOLDERS TROUV√âS :');
        const placeholderPattern = /\{\{([^}]+)\}\}/g;
        let placeholderMatch;
        let placeholderIndex = 1;
        
        while ((placeholderMatch = placeholderPattern.exec(xmlContent)) !== null) {
          console.log(`   ${placeholderIndex}. {{${placeholderMatch[1]}}}`);
          placeholderIndex++;
        }
        
        // 4. Chercher les placeholders sp√©cifiques REF_
        console.log('\nüéØ [DEBUG] PLACEHOLDERS "REF_" TROUV√âS :');
        const refPlaceholderPattern = /\{\{(REF_[^}]+)\}\}/g;
        let refPlaceholderMatch;
        let refPlaceholderFound = false;
        
        while ((refPlaceholderMatch = refPlaceholderPattern.exec(xmlContent)) !== null) {
          console.log(`   ‚úÖ Trouv√©: {{${refPlaceholderMatch[1]}}}`);
          refPlaceholderFound = true;
        }
        
        if (!refPlaceholderFound) {
          console.log('   ‚ùå AUCUN placeholder "REF_" trouv√© !');
        }
        
        // 5. Extraire un √©chantillon du XML pour inspection manuelle
        console.log('\nüìÑ [DEBUG] √âCHANTILLON DU XML (premiers 500 caract√®res) :');
        console.log(xmlContent.substring(0, 500) + '...');
        
        // 6. Chercher les structures p:txBody (zones de texte)
        console.log('\nüìù [DEBUG] ZONES DE TEXTE TROUV√âES :');
        const txBodyPattern = /<p:txBody[^>]*>([\s\S]*?)<\/p:txBody>/g;
        let txBodyMatch;
        let txBodyIndex = 1;
        
        while ((txBodyMatch = txBodyPattern.exec(xmlContent)) !== null) {
          const textContent = txBodyMatch[1];
          // Extraire le texte lisible
          const textPattern = /<a:t[^>]*>(.*?)<\/a:t>/g;
          let textMatch;
          let extractedText = '';
          
          while ((textMatch = textPattern.exec(textContent)) !== null) {
            extractedText += textMatch[1] + ' ';
          }
          
          console.log(`   ${txBodyIndex}. Contenu: "${extractedText.trim()}"`);
          txBodyIndex++;
        }
      }
    }
  }
  
  console.log('\nüîç [DEBUG] === FIN DE L\'ANALYSE ===\n');
}

// ===== ENDPOINTS =====

// Test de sant√©
app.get('/api/test', (req, res) => {
  console.log('üîç [API] Test endpoint appel√©');
  res.json({ 
    ok: true, 
    timestamp: new Date().toISOString(),
    message: 'Backend fonctionnel'
  });
});

// Servir le template PowerPoint
app.get('/template.pptx', (req, res) => {
  console.log('üìÅ [TEMPLATE] Demande de template');
  const templatePath = path.join(__dirname, 'template.pptx');
  
  if (!fs.existsSync(templatePath)) {
    console.error('‚ùå [TEMPLATE] Fichier template.pptx introuvable');
    return res.status(404).json({ error: 'Template non trouv√©' });
  }
  
  console.log('‚úÖ [TEMPLATE] Envoi du template');
  res.sendFile(templatePath);
});

// Endpoint principal : enrichissement de CV
app.post('/api/enrich-cv', upload.single('pptx'), async (req, res) => {
  console.log('\n=== üöÄ [ENRICH-CV] D√âBUT TRAITEMENT ===');
  console.log('üìÖ Timestamp:', new Date().toISOString());
  
  try {
    // 1. Validation du fichier
    if (!req.file) {
      console.error('‚ùå [ENRICH-CV] Aucun fichier fourni');
      return res.status(400).json({ error: 'Aucun fichier fourni' });
    }
    
    console.log('üìÅ [ENRICH-CV] Fichier re√ßu:', {
      originalName: req.file.originalname,
      size: req.file.size,
      path: req.file.path
    });
    
    // 2. Parse des r√©f√©rences
    let references = [];
    try {
      references = JSON.parse(req.body.references || '[]');
      console.log('üìã [ENRICH-CV] R√©f√©rences pars√©es:', references.length, '√©l√©ments');
      if (references.length > 0) {
        console.log('üìã [ENRICH-CV] R√©f√©rences re√ßues:');
        references.forEach((ref, index) => {
          console.log(`   ${index + 1}. ${ref.nom_projet || ref.residence} - ${ref.client || ref.moa}`);
        });
      }
    } catch (err) {
      console.error('‚ùå [ENRICH-CV] Erreur parsing JSON:', err.message);
      fs.unlinkSync(req.file.path);
      return res.status(400).json({ error: 'Format JSON invalide pour les r√©f√©rences' });
    }
    
    // 3. Lecture du fichier PPTX
    console.log('üìñ [ENRICH-CV] Lecture du fichier PPTX...');
    const zip = new JSZip();
    const fileBuffer = fs.readFileSync(req.file.path);
    const content = await zip.loadAsync(fileBuffer);
    
    // 4. Remplacement par shape nomm√©e (corrig√©)
    const replacements = await remplacerPlaceholdersParShape(content, references);
    
    console.log('‚úÖ [ENRICH-CV] Remplacement par shape termin√©');
    console.log(`üìä [ENRICH-CV] ${references.length} r√©f√©rences utilis√©es, ${replacements} shapes mises √† jour`);
    
    // 5. Masquage des shapes vides (seulement si n√©cessaire)
    let shapesMasquees = 0;
    if (references.length < 5) {
      shapesMasquees = await masquerShapesParSuppressionContenu(content, references);
    } else {
      console.log('üé≠ [MASQUAGE] Aucun masquage n√©cessaire (5 r√©f√©rences ou plus)');
    }
    
    // 6. G√©n√©ration du fichier de sortie
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const outputFilename = `cv_enrichi_${timestamp}.pptx`;
    const outputPath = path.join(downloadsDir, outputFilename);
    
    console.log('üíæ [ENRICH-CV] G√©n√©ration du fichier:', outputFilename);
    const outputBuffer = await content.generateAsync({ type: 'nodebuffer' });
    fs.writeFileSync(outputPath, outputBuffer);
    
    // 7. Nettoyage du fichier temporaire
    fs.unlinkSync(req.file.path);
    console.log('üßπ [ENRICH-CV] Fichier temporaire supprim√©');
    
    // 8. R√©ponse de succ√®s
    const response = {
      message: 'CV enrichi g√©n√©r√© avec succ√®s',
      filename: outputFilename,
      downloadUrl: `/api/download/${outputFilename}`,
      referencesCount: references.length,
      replacements: replacements,
      shapesMasquees: shapesMasquees,
      fileSize: outputBuffer.length
    };
    
    console.log('‚úÖ [ENRICH-CV] Succ√®s:', response);
    console.log('=== üèÅ [ENRICH-CV] FIN TRAITEMENT ===\n');
    
    res.json(response);
    
  } catch (error) {
    console.error('üí• [ENRICH-CV] ERREUR:', error.message);
    console.error('üí• [ENRICH-CV] Stack:', error.stack);
    
    // Nettoyage en cas d'erreur
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
      console.log('üßπ [ENRICH-CV] Fichier temporaire supprim√© apr√®s erreur');
    }
    
    res.status(500).json({ 
      error: 'Erreur lors de l\'enrichissement du CV',
      details: error.message 
    });
  }
});

// Liste des fichiers t√©l√©chargeables
app.get('/api/downloads', (req, res) => {
  console.log('üìÅ [DOWNLOADS] Liste des t√©l√©chargements demand√©e');
  
  try {
    const files = fs.readdirSync(downloadsDir)
      .filter(f => f.endsWith('.pptx'))
      .map(f => {
        const fullPath = path.join(downloadsDir, f);
        const stat = fs.statSync(fullPath);
        return {
          filename: f,
          sizeBytes: stat.size,
          createdAt: stat.birthtimeMs || stat.ctimeMs,
          formattedSize: `${Math.round(stat.size / 1024)} KB`
        };
      })
      .sort((a, b) => b.createdAt - a.createdAt); // Plus r√©cents en premier
    
    console.log('üìä [DOWNLOADS] Fichiers trouv√©s:', files.length);
    res.json({ files });
    
  } catch (error) {
    console.error('‚ùå [DOWNLOADS] Erreur:', error.message);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des fichiers' });
  }
});

// T√©l√©chargement d'un fichier
app.get('/api/download/:filename', (req, res) => {
  const filename = safeFilename(req.params.filename);
  const filePath = path.join(downloadsDir, filename);
  
  console.log('‚¨áÔ∏è [DOWNLOAD] T√©l√©chargement demand√©:', filename);
  
  if (!fs.existsSync(filePath)) {
    console.error('‚ùå [DOWNLOAD] Fichier introuvable:', filename);
    return res.status(404).json({ error: 'Fichier introuvable' });
  }
  
  console.log('‚úÖ [DOWNLOAD] Envoi du fichier:', filename);
  res.download(filePath, filename, (err) => {
    if (err) {
      console.error('‚ùå [DOWNLOAD] Erreur envoi:', err.message);
    } else {
      console.log('‚úÖ [DOWNLOAD] Fichier envoy√© avec succ√®s:', filename);
    }
  });
});

// Suppression d'un fichier
app.delete('/api/download/:filename', (req, res) => {
  const filename = safeFilename(req.params.filename);
  const filePath = path.join(downloadsDir, filename);
  
  console.log('üóëÔ∏è [DELETE] Suppression demand√©e:', filename);
  
  if (!fs.existsSync(filePath)) {
    console.error('‚ùå [DELETE] Fichier introuvable:', filename);
    return res.status(404).json({ error: 'Fichier introuvable' });
  }
  
  try {
    fs.unlinkSync(filePath);
    console.log('‚úÖ [DELETE] Fichier supprim√©:', filename);
    res.json({ message: 'Fichier supprim√© avec succ√®s' });
  } catch (error) {
    console.error('‚ùå [DELETE] Erreur suppression:', error.message);
    res.status(500).json({ error: 'Erreur lors de la suppression' });
  }
});

// D√©marrage du serveur
app.listen(PORT, () => {
  console.log('\nüöÄ ===== BACKEND CV ENRICHMENT =====');
  console.log(`üåê Serveur d√©marr√© sur http://localhost:${PORT}`);
  console.log('üìÅ Dossier uploads:', uploadsDir);
  console.log('üìÅ Dossier downloads:', downloadsDir);
  console.log('üìã Endpoints disponibles:');
  console.log('   ‚Ä¢ GET  /api/test');
  console.log('   ‚Ä¢ GET  /template.pptx');
  console.log('   ‚Ä¢ POST /api/enrich-cv');
  console.log('   ‚Ä¢ GET  /api/downloads');
  console.log('   ‚Ä¢ GET  /api/download/:filename');
  console.log('   ‚Ä¢ DEL  /api/download/:filename');
  console.log('=====================================\n');
});

// Gestion des erreurs non captur√©es
process.on('uncaughtException', (error) => {
  console.error('üí• [FATAL] Erreur non captur√©e:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üí• [FATAL] Promise rejet√©e:', reason);
  process.exit(1);
});
